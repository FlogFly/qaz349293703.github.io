<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>搬砖的码农</title>
  
  <subtitle>青蛙要fly</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-12-19T06:53:41.596Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>青蛙要fly</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>项目需求讨论 — ConstraintLayout 详细使用教程</title>
    <link href="http://yoursite.com/2017/12/17/ConstranitLayout%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2017/12/17/ConstranitLayout教程/</id>
    <published>2017-12-16T16:00:00.000Z</published>
    <updated>2017-12-19T06:53:41.596Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1529568-3da2dfcf5bd9d38d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>文章摘要：ConstraintLayout的基础知识及使用教程<br><a id="more"></a></p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><p>最近转方向参与到物联网的项目去了。看的都是C++和Node.js,表示从头学习，又变成了一个小菜鸟了。所以好久没写过文章了。</p><p>废话不多说，关于ConstraintLayout的文章网上一抓一大把，而且ConstraintLayout在16年就已经出来了，但是我一直没有试着去使用(别问我为什么不去使用,当然是因为懒啊)。毕竟前面的LinearLayout搭配RelativeLayout用习惯了，但是毕竟能减少布局的嵌套。还是要抱着多学习的方式去接触。所以写下文章作为总结。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大家都知道AS在写相关布局的时候，有二种方式：</p><h4 id="1-拖拽方式"><a href="#1-拖拽方式" class="headerlink" title="1. 拖拽方式"></a>1. 拖拽方式</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/160541929dc4d475?w=1013&amp;h=787&amp;f=png&amp;s=83890" alt=""></p><p>就是在这里进行拖控件，各种操作，因为在以前RelativeLayout和LinearLayout的年代，自己拖会自动帮我们添加各种属性值不说，而且还很不方便，但是对于ConstraintLayout来说添加各种约束在这里操作反而很方便，而且这里的功能面板也增加了很多新功能，方便了很多。</p><p>当然我也不多说，贴上郭霖大神写得在这里功能面板里面对ConstraintLayout 各种操作方式：<br><a href="http://blog.csdn.net/guolin_blog/article/details/53122387" target="_blank" rel="noopener">操作面板拖拽方式来使用ConstraintLayout</a></p><h4 id="2-编写代码"><a href="#2-编写代码" class="headerlink" title="2.编写代码"></a>2.编写代码</h4><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/160542997a9b304f?w=1193&amp;h=621&amp;f=png&amp;s=100255" alt=""></p><p>这种更为大家使用，而我这里也更多的是直接写代码的方式。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="控件如何确定自己的位置"><a href="#控件如何确定自己的位置" class="headerlink" title="控件如何确定自己的位置"></a>控件如何确定自己的位置</h3><h5 id="1-直接确定控件左上角的坐标"><a href="#1-直接确定控件左上角的坐标" class="headerlink" title="1.直接确定控件左上角的坐标"></a>1.直接确定控件左上角的坐标</h5><p>在约束布局中，一个控件如何来确定自己的位置呢，有人可能说直接写死让它在界面的（XXX,XXX）位置不就好了么。</p><p>比如在拖拽界面，我们把一个TextView拖到了界面中间。</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16054325bb53e7b2?w=631&amp;h=548&amp;f=png&amp;s=10599" alt=""></p><p>我们发现这个TextView的确在中间了，这时候我们看下它的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;我在哪里&quot;</span><br><span class="line">        tools:layout_editor_absoluteX=&quot;164dp&quot;</span><br><span class="line">        tools:layout_editor_absoluteY=&quot;263dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure><p>我们发现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tools:layout_editor_absoluteX=&quot;164dp&quot;</span><br><span class="line">tools:layout_editor_absoluteY=&quot;263dp&quot;</span><br></pre></td></tr></table></figure></p><p>的确我们告诉了TextView的左上角的坐标，这个TextView的确可以确定了位置，但是这二个属性只是单纯的进行演示，在真机操作的时候是无效的，就像”tools:text”一样，可以在写布局的时候方便查看TextView显示的文字，但是实际运行app的时候不会有相应内容。</p><p>而且我们也可以看到布局文件中有错误提示，也告诉我们在真实运行时候会跳到(0,0)位置：</p><blockquote><p>This view is not constrained, it only has designtime positions, so it will jump to (0,0) unless you add constraints less…</p></blockquote><h5 id="2-告诉控件相邻的二个边的位置情况"><a href="#2-告诉控件相邻的二个边的位置情况" class="headerlink" title="2.告诉控件相邻的二个边的位置情况"></a>2.告诉控件相邻的二个边的位置情况</h5><p>如下图所示：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16054431d50c90cc?w=243&amp;h=374&amp;f=png&amp;s=2944" alt=""></p><p><strong>我们怎么来确定它们的位置？比如我们红色的矩形A，我们是不是告诉它：你的左边靠着外面界面的左边，你的顶边靠着外面界面的顶边（然后是不是A就处在现在这个位置了）。绿色的矩形B我们可以告诉它：你的右边靠着外面界面的右边，你的底边靠着外面界面的底边（然后B就处在了现在这个位置）。</strong></p><p>所以基本操作就是：确定某个控件二个边的位置（比如靠在哪个控件旁边）。</p><p>我们来看最简单的基本操作：<br><strong>layout<em>constraint[自己位置]</em>[目标位置]=”[目标ID]”</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintLeft_toLeftOf</span><br><span class="line">layout_constraintLeft_toRightOf</span><br><span class="line">layout_constraintRight_toLeftOf</span><br><span class="line">layout_constraintRight_toRightOf</span><br><span class="line">layout_constraintTop_toTopOf</span><br><span class="line">layout_constraintTop_toBottomOf</span><br><span class="line">layout_constraintBottom_toTopOf</span><br><span class="line">layout_constraintBottom_toBottomOf</span><br><span class="line">layout_constraintBaseline_toBaselineOf</span><br><span class="line">layout_constraintStart_toEndOf</span><br><span class="line">layout_constraintStart_toStartOf</span><br><span class="line">layout_constraintEnd_toStartOf</span><br><span class="line">layout_constraintEnd_toEndOf</span><br></pre></td></tr></table></figure></p><p>举个例子：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/14/16054587a8907e9b?w=475&amp;h=234&amp;f=png&amp;s=4857" alt=""></p><p>比如我们A按钮已经确定好位置了。我们现在要放B按钮，就像我们上面说的，我们B按钮的二个边的位置，我们可以设置让B按钮的左边靠着A按钮的右边（相当于B按钮的左边与A按钮的右边处于同一位置）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button android:id=&quot;@+id/buttonA&quot; ... /&gt;</span><br><span class="line"></span><br><span class="line">&lt;Button android:id=&quot;@+id/buttonB&quot; ...</span><br><span class="line">    app:layout_constraintLeft_toRightOf=&quot;@+id/buttonA&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>我们可以看到<code>app:layout_constraintLeft_toRightOf=&quot;@+id/buttonA&quot;</code>，B的<code>left</code>与<code>id</code>为<code>buttonA</code>的控件的<code>right</code>相同位置。所以B的左侧就和A的右侧贴在了一起。</p><p><strong>我们发现上面还有一个<code>layout_constraintBaseline_toBaselineOf</code>，直接看下图就可以理解所有相关的属性：<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/1606257f19a24a34?w=574&amp;h=155&amp;f=png&amp;s=7477" alt=""></strong></p><p>如果是相对于父布局，我们也可以不写入另外一个控件的id值，直接填parent值就可以了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout ...&gt;</span><br><span class="line">    &lt;Button android:id=&quot;@+id/button&quot; ...</span><br><span class="line">     app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">     /&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.constraint.ConstraintLayout/&gt;</span><br></pre></td></tr></table></figure></p><p>所以以上就是基本的操作。我们接下来看下其他的特殊属性。</p><hr><h3 id="Margin值相关"><a href="#Margin值相关" class="headerlink" title="Margin值相关"></a>Margin值相关</h3><p>比如我们上面的A和B按钮通过了<code>app:layout_constraintLeft_toRightOf</code>拼接在一起了，但是我同时希望A和B按钮中间能空一些距离，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/160625f3bd1532c6?w=483&amp;h=143&amp;f=png&amp;s=4374" alt=""><br>我们可以直接使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android:layout_marginStart</span><br><span class="line">android:layout_marginEnd</span><br><span class="line">android:layout_marginLeft</span><br><span class="line">android:layout_marginTop</span><br><span class="line">android:layout_marginRight</span><br><span class="line">android:layout_marginBottom</span><br></pre></td></tr></table></figure></p><p>这时候就又会有一个问题，如果这时候A的<code>visible</code>为<code>gone</code>,这时候B的位置就会自动往左边了。因为A的所占的宽度没有了（但是A在里面对于其他控件的约束性都是还是存在的）<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062f56eee9a3f2?w=540&amp;h=262&amp;f=png&amp;s=7147" alt="">但是如果我的需求就是A隐藏后，B还是在这个位置（当然有些人可能会说你可以让B根据其他控件来确定位置），而且我的B的位置就是根据A来确定的。那我们怎么处理，我们可以设置B的以下属性，就是当A处于<code>gone</code>的时候，我们可以让B的margin值是根据以下的属性值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">layout_goneMarginStart</span><br><span class="line">layout_goneMarginEnd</span><br><span class="line">layout_goneMarginLeft</span><br><span class="line">layout_goneMarginTop</span><br><span class="line">layout_goneMarginRight</span><br><span class="line">layout_goneMarginBottom</span><br></pre></td></tr></table></figure></p><hr><h3 id="位置约束不止二个边"><a href="#位置约束不止二个边" class="headerlink" title="位置约束不止二个边"></a>位置约束不止二个边</h3><p>我们上面提过，二个边的位置确定好了（也可以说二个边的位置被约束了），我们就可以确定这个控件的相应位置，而且还可以通过margin的改变，来继续调节控件的位置。那如果我这时候是三个边约束或者四个边都约束了呢，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout ...&gt;</span><br><span class="line">    &lt;Button android:id=&quot;@+id/button&quot; ...</span><br><span class="line">     app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintRight_toRightOf=&quot;parent/&gt;</span><br><span class="line"></span><br><span class="line">&lt;android.support.constraint.ConstraintLayout/&gt;</span><br></pre></td></tr></table></figure></p><p>我们让按钮的左边与父布局的左边对齐，让按钮的右边与父布局的右边对齐。这时候因为不是单纯的一边对齐，而是相同直线上的二个边都被约束了。所以按钮无法紧靠着左边的或者右边的其中一个边界，所以这时候，这个按钮就会居于二个约束边界的中间位置。如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062d7ac0ba8af0?w=421&amp;h=97&amp;f=png&amp;s=2618" alt=""><br>也许也有人问，我想在这二个约束条件下时候不是处于正中间，而是处于左边三分之一的位置，这时候你可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintHorizontal_bias</span><br><span class="line">layout_constraintVertical_bias</span><br></pre></td></tr></table></figure></p><p>分别是水平和垂直方向上的所占比例。<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062e077f68081b?w=421&amp;h=97&amp;f=png&amp;s=2567" alt=""><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout ...&gt;</span><br><span class="line">    &lt;Button android:id=&quot;@+id/button&quot; ...</span><br><span class="line">     app:layout_constraintHorizontal_bias=&quot;0.3&quot;</span><br><span class="line">     app:layout_constraintLeft_toLeftOf=&quot;parent&quot;</span><br><span class="line">     app:layout_constraintRight_toRightOf=&quot;parent/&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure></p><hr><h3 id="圆形布局"><a href="#圆形布局" class="headerlink" title="圆形布局"></a>圆形布局</h3><p>有些需求我们可能需要让控件以某个控件为中心，绕着进行布局，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062e33639abb69?w=325&amp;h=325&amp;f=png&amp;s=5813" alt=""><br>ConstarintLayout自带了这些功能，我们可以使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintCircle : 引用另一个控件的id</span><br><span class="line">layout_constraintCircleRadius : 距离另外一个控件中心的距离</span><br><span class="line">layout_constraintCircleAngle : 应该在哪个角度(从0到360度)</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16062e32e05ee6e3?w=325&amp;h=325&amp;f=png&amp;s=5863" alt=""><br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button android:id=&quot;@+id/buttonA&quot; ... /&gt;</span><br><span class="line">&lt;Button android:id=&quot;@+id/buttonB&quot; ...</span><br><span class="line">  app:layout_constraintCircle=&quot;@+id/buttonA&quot;</span><br><span class="line">  app:layout_constraintCircleRadius=&quot;100dp&quot;</span><br><span class="line">  app:layout_constraintCircleAngle=&quot;45&quot; /&gt;</span><br></pre></td></tr></table></figure></p><hr><h3 id="尺寸限制（Dimensions-constraints）"><a href="#尺寸限制（Dimensions-constraints）" class="headerlink" title="尺寸限制（Dimensions constraints）"></a>尺寸限制（Dimensions constraints）</h3><h5 id="1-对ConstraintLayout进行限制："><a href="#1-对ConstraintLayout进行限制：" class="headerlink" title="1.对ConstraintLayout进行限制："></a>1.对ConstraintLayout进行限制：</h5><p>您可以为ConstraintLayout本身定义最小和最大尺寸：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android：minWidth设置布局的最小宽度</span><br><span class="line">android：minHeight设置布局的最小高度</span><br><span class="line">android：maxWidth设置布局的最大宽度</span><br><span class="line">android：maxHeight设置布局的最大高度</span><br></pre></td></tr></table></figure></p><p>这些最小和最大尺寸将在ConstraintLayout使用</p><h5 id="2-对内部的控件进行限制："><a href="#2-对内部的控件进行限制：" class="headerlink" title="2.对内部的控件进行限制："></a>2.对内部的控件进行限制：</h5><p>可以通过以3种不同方式设置<code>android：layout_width</code>和<code>android：layout_height</code>属性来指定控件的尺寸：</p><ul><li>用特定的值（如123dp等）</li><li>使用WRAP_CONTENT，它会要求控件计算自己的大小</li><li><p>使用0dp，相当于“MATCH_CONSTRAINT”</p><p><strong>WRAP_CONTENT（在1.1中添加）</strong></p><p>如果设置为WRAP_CONTENT，则在1.1之前的版本中， 约束不会限制生成的尺寸值。但是在某些情况下，您可能需要使用WRAP_CONTENT，但仍然执行约束来限制生成的尺寸值。在这种情况下，你可以添加一个相应的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">应用：layout_constrainedWidth =”真|假”</span><br><span class="line">应用：layout_constrainedHeight =”真|假”</span><br></pre></td></tr></table></figure></li></ul><p><strong>MATCH_CONSTRAINT尺寸(也就是0dp)（在1.1中添加）</strong></p><p>设置为MATCH_CONSTRAINT时，默认是大小是占用所有可用空间。有几个额外的修饰符可用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">layout_constraintWidth_min和layout_constraintHeight_min：将设置此维度的最小尺寸</span><br><span class="line">layout_constraintWidth_max和layout_constraintHeight_max：将设置此维度的最大尺寸</span><br><span class="line">layout_constraintWidth_percent和layout_constraintHeight_percent：将设置此维度的大小为父级的百分比</span><br></pre></td></tr></table></figure></p><hr><h3 id="百分比尺寸（Percent-Dimensions）"><a href="#百分比尺寸（Percent-Dimensions）" class="headerlink" title="百分比尺寸（Percent Dimensions）"></a>百分比尺寸（Percent Dimensions）</h3><p>说到Percent Dimensions就不得不说ConstraintLayout中的0dp问题，当控件设置为0dp的时候（0dp的称呼又叫match_constraint），默认的行为是撑开（spread），占满可用空间，但是这个行为是可以用layout_constraintWidth_default 属性来设置的。在 ConstraintLayout 1.0.x中，这个属性还可以把它设置为wrap。而到了1.1.x，它又有了一个新的值：percent，允许我们设置控件占据可用空间的百分比。</p><blockquote><p>（注意：这在1.1-beta1和1.1-beta2中layout_constraintWidth_default是必须的，但是如果percent属性被定义,则在以下版本中不需要，然后将layout_constraintWidth_percent或layout_constraintHeight_percent属性设置为介于0和1之间的值）</p></blockquote><p>下面的TextView控件将占据剩余宽度的50%和剩余高度的50%:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">  android:id=&quot;@+id/textView6&quot;</span><br><span class="line">  android:layout_width=&quot;0dp&quot;</span><br><span class="line">  android:layout_height=&quot;0dp&quot;</span><br><span class="line"></span><br><span class="line">  app:layout_constraintHeight_default=&quot;percent&quot;</span><br><span class="line">  app:layout_constraintHeight_percent=&quot;0.5&quot;</span><br><span class="line"></span><br><span class="line">  app:layout_constraintWidth_default=&quot;percent&quot;</span><br><span class="line">  app:layout_constraintWidth_percent=&quot;0.5&quot; /&gt;</span><br></pre></td></tr></table></figure></p><hr><h3 id="宽高比（Ratio）"><a href="#宽高比（Ratio）" class="headerlink" title="宽高比（Ratio）"></a>宽高比（Ratio）</h3><p>您还可以控制控件的height或者width这二个值，让其中一个值与另外一个值的成特定的比例。为此，需要至少将一个值设置为0dp（即，MATCH_CONSTRAINT），并将属性layout_constraintDimensionRatio设置为给定比率。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">   android:layout_height=&quot;0dp&quot;</span><br><span class="line">   app:layout_constraintDimensionRatio=&quot;1:1&quot; /&gt;</span><br></pre></td></tr></table></figure></p><p>这样这个按钮的宽和高是一样大小的。</p><p><strong>Ratio可以设置为：</strong></p><ul><li>浮点值，表示宽度和高度之间的比率</li><li>“宽度：高度”形式的比率</li></ul><p><strong>如果两个维都设置为MATCH_CONSTRAINT（0dp），则也可以使用比率：</strong> 在这种情况下，系统设置满足所有约束条件的最大尺寸并保持指定的宽高比。</p><p><strong>为了约束一个特定的边，可以根据另一个边的大小来限定宽度或高度：</strong><br>可以通过在比率前面添加字母W（用于限制宽度）或H（用于限制高度），用逗号分隔来指示哪一边应该受到约束：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button android:layout_width=&quot;0dp&quot;</span><br><span class="line">   android:layout_height=&quot;0dp&quot;</span><br><span class="line">   app:layout_constraintDimensionRatio=&quot;H,16:9&quot;</span><br><span class="line">   app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">   app:layout_constraintTop_toTopOf=&quot;parent&quot;/&gt;</span><br></pre></td></tr></table></figure></p><p>将按照16：9的比例设置按钮的高度，而按钮的宽度将匹配父布局的约束。</p><hr><h3 id="链（Chains）"><a href="#链（Chains）" class="headerlink" title="链（Chains）"></a>链（Chains）</h3><p>链在单个轴（水平或垂直）中提供类似组的行为。</p><ul><li><strong>创建一个链:</strong><br>如果一组小部件通过双向连接链接在一起，则认为它们是一个链,如下图所示，是一个具有二个控件的最小的链：<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16064ae82e58df64?w=630&amp;h=174&amp;f=png&amp;s=6494" alt=""></li><li><strong>链头:</strong><br>链由在链的第一个元素（链的“头”）上设置的属性控制：<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16064afa73faf3bd?w=917&amp;h=135&amp;f=png&amp;s=7722" alt=""><br>（头是水平链最左边的部件，也是垂直链最顶端的部件。）</li><li><strong>链样式:</strong> 在链的第一个元素上设置属性<code>layout_constraintHorizontal_chainStyle</code>或<code>layout_constraintVertical_chainStyle</code>时，链的行为将根据指定的样式进行更改（默认为CHAIN_SPREAD）。<img src="https://user-gold-cdn.xitu.io/2017/12/17/16064b751691da00?w=1368&amp;h=616&amp;f=png&amp;s=45202" alt="">例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line">    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/textView2&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;AAAA&quot;</span><br><span class="line">        app:layout_constraintHorizontal_chainStyle=&quot;spread&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintEnd_toStartOf=&quot;@id/textView3&quot;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/textView3&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;BBBB&quot;</span><br><span class="line">        app:layout_constraintEnd_toStartOf=&quot;@id/textView4&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toEndOf=&quot;@+id/textView2&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id=&quot;@+id/textView4&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:text=&quot;CCCC&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintEnd_toEndOf=&quot;parent&quot;</span><br><span class="line">        app:layout_constraintStart_toEndOf=&quot;@+id/textView3&quot; /&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure></li></ul><p>效果如下：<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16064b9f18dea5be?w=686&amp;h=280&amp;f=png&amp;s=14729" alt=""></p><hr><h3 id="屏障-Barrier"><a href="#屏障-Barrier" class="headerlink" title="屏障 (Barrier)"></a>屏障 (Barrier)</h3><p>Barrier是一个虚拟的辅助控件，它可以阻止一个或者多个控件越过自己，就像一个屏障一样。当某个控件要越过自己的时候，Barrier会自动移动，避免自己被覆盖。</p><p>关于这个控件其他文章有详细的介绍，我直接附上地址：<br> <a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/1017/8601.html" target="_blank" rel="noopener"><strong>ConstraintLayout之Barrier</strong></a>。</p><hr><h3 id="组（Group）"><a href="#组（Group）" class="headerlink" title="组（Group）"></a>组（Group）</h3><p>Group帮助你对一组控件进行设置。最常见的情况是控制一组控件的visibility。你只需把控件的id添加到Group，就能同时对里面的所有控件进行操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout ...&gt;</span><br><span class="line">  &lt;TextView</span><br><span class="line">    android:id=”@+id/text1&quot; ... /&gt;</span><br><span class="line">  &lt;TextView</span><br><span class="line">    android:id=”@+id/text2&quot; ... /&gt;</span><br><span class="line">  &lt;android.support.constraint.Group</span><br><span class="line">    android:id=”@+id/group”</span><br><span class="line">    ...</span><br><span class="line">    app:constraint_referenced_ids=”text1,text2&quot; /&gt;</span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure></p><p>此时如果我们调用<code>group.setVisibility(View.GONE);</code>那么text1 和 text2 都将不可见。</p><hr><h3 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h3><p>ConstraintLayout的辅助对象的实用程序类。Guideline不会显示在设备上（它们被标记为View.GONE），仅用于布局。他们只能在ConstraintLayout中工作。</p><p>指引可以是水平的也可以是垂直的：<br>垂直指南的宽度为零，它们的ConstraintLayout父项的高度为零<br>水平指南的高度为零，其ConstraintLayout父项的宽度为零<br><strong>定位准则有三种不同的方式：</strong></p><ul><li>指定布局左侧或顶部的固定距离（layout_constraintGuide_begin）</li><li>从布局的右侧或底部指定固定距离（layout_constraintGuide_end）</li><li>指定布局的宽度或高度的百分比（layout_constraintGuide_percent）<blockquote><p>相应的代码为setGuidelineBegin（int，int），setGuidelineEnd（int，int）和setGuidelinePercent（int，float）函数。</p></blockquote></li></ul><p>然后控件就可以被Guideline来约束。（换句话就是说弄了一个隐藏的View，来约束我们的控件，我们的控件相对的就更容易进行位置定位）。</p><p><strong>限制于垂直Guideline的按钮示例：</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;android.support.constraint.ConstraintLayout</span><br><span class="line">        xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">        xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">        xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.constraint.Guideline</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:id=&quot;@+id/guideline&quot;</span><br><span class="line">            app:layout_constraintGuide_begin=&quot;100dp&quot;</span><br><span class="line">            android:orientation=&quot;vertical&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;Button</span><br><span class="line">            android:text=&quot;Button&quot;</span><br><span class="line">            android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">            android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">            android:id=&quot;@+id/button&quot;</span><br><span class="line">            app:layout_constraintLeft_toLeftOf=&quot;@+id/guideline&quot;</span><br><span class="line">            android:layout_marginTop=&quot;16dp&quot;</span><br><span class="line">            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure></p><hr><h3 id="Placeholder"><a href="#Placeholder" class="headerlink" title="Placeholder"></a>Placeholder</h3><p>大家具体使用可以看这篇文章：<br><a href="http://androidkt.com/constraintlayout/" target="_blank" rel="noopener"><strong>New features in ConstraintLayout 1.1.x</strong></a>。<br>我以下Placeholder内容也就转载这个文章里面的例子：</p><p>Placeholder顾名思义，就是用来一个占位的东西，它可以把自己的内容设置为ConstraintLayout内的其它view。因此它用来写布局的模版，也可以用来动态修改UI的内容。</p><p><strong>用作模版：</strong><br>我们用Placeholder创建一个名为template.xml的模版：</p><p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16064c4afd14aeaf?w=769&amp;h=631&amp;f=png&amp;s=27768" alt=""><br>模版写好了我们来填充真正的东西。</p><p>我们把刚才定义的模版include到真正的布局文件中，并且在这个布局文件中添加真实的控件，注意这里的控件无需添加任何约束，因为它们的位置是由Placeholder决定的。</p><p>还有一点就是模版要放在被引用的所有控件之前：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;android.support.constraint.ConstraintLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:id=&quot;@+id/root&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</span><br><span class="line">    tools:context=&quot;com.app.androidkt.constraintlayoutb.MainActivity&quot;</span><br><span class="line">    tools:showIn=&quot;@layout/activity_main&quot;&gt;</span><br><span class="line">    &lt;include layout=&quot;@layout/template&quot; /&gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/top_image&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:scaleType=&quot;fitXY&quot;</span><br><span class="line">        android:src=&quot;@drawable/place_holder_demo&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageButton</span><br><span class="line">        android:id=&quot;@+id/save&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginBottom=&quot;16dp&quot;</span><br><span class="line">        app:layout_constraintBottom_toBottomOf=&quot;parent&quot;</span><br><span class="line">        app:srcCompat=&quot;@drawable/ic_save_black_24dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageButton</span><br><span class="line">        android:id=&quot;@+id/edit&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        app:srcCompat=&quot;@drawable/ic_edit_black_24dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageButton</span><br><span class="line">        android:id=&quot;@+id/cancel&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginBottom=&quot;16dp&quot;</span><br><span class="line"></span><br><span class="line">        app:srcCompat=&quot;@drawable/ic_cancel_black_24dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageButton</span><br><span class="line">        android:id=&quot;@+id/delete&quot;</span><br><span class="line">        android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">        android:layout_marginBottom=&quot;16dp&quot;</span><br><span class="line"></span><br><span class="line">        app:srcCompat=&quot;@drawable/ic_delete_black_24dp&quot; /&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;/android.support.constraint.ConstraintLayout&gt;</span><br></pre></td></tr></table></figure></p><p><img src="https://user-gold-cdn.xitu.io/2017/12/17/16064c59dc20a1e7?w=769&amp;h=635&amp;f=png&amp;s=176545" alt=""><br>以上就是PlaceHolder的使用场景之一模版功能。</p><p><strong>动态替换:</strong><br>PlaceHolder还可以在Java代码中动态替换自己的内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">  private Placeholder placeholder;</span><br><span class="line">  private ConstraintLayout root;</span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  public void onClick(View view) &#123;</span><br><span class="line">    placeholder.setContentId(view.getId());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果结合过渡动画的话，就可以实现一些比较有趣的效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">  private Placeholder placeholder;</span><br><span class="line">  private ConstraintLayout root;</span><br><span class="line">  @Override</span><br><span class="line">  public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  public void onClick(View view) &#123;</span><br><span class="line">    TransitionManager.beginDelayedTransition(root);</span><br><span class="line">    placeholder.setContentId(view.getId());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>下面是使用PlaceHolder结合过渡动画实现的效果：<br><img src="https://user-gold-cdn.xitu.io/2017/12/17/16064c793341a380?w=480&amp;h=854&amp;f=gif&amp;s=510684" alt=""><br>而这个Demo也是上面那篇文章作者附上的，Demo地址是<a href="https://github.com/Thumar/Placeholder" target="_blank" rel="noopener"><strong>PlaceHolder动态替换</strong></a></p><hr><h3 id="结语："><a href="#结语：" class="headerlink" title="结语："></a>结语：</h3><p>还是老话，哪里不对。可以在留言处写出来。我会进行更正，哈哈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1529568-3da2dfcf5bd9d38d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;文章摘要：ConstraintLayout的基础知识及使用教程&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="ConstraintLayout" scheme="http://yoursite.com/tags/ConstraintLayout/"/>
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>图片操作系列 —（2）手势旋转图片</title>
    <link href="http://yoursite.com/2017/11/27/%E5%9B%BE%E7%89%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%97%20%E2%80%94%EF%BC%882%EF%BC%89%E6%89%8B%E5%8A%BF%E6%97%8B%E8%BD%AC%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2017/11/27/图片操作系列 —（2）手势旋转图片/</id>
    <published>2017-11-26T16:00:00.000Z</published>
    <updated>2017-12-19T07:02:14.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1529568-f083a0346aa3af63.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>文章摘要：根据手势操作图片旋转<br><a id="more"></a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上次的文章：<a href="https://juejin.im/post/59fbdf5851882554bd5068ed" target="_blank" rel="noopener">图片操作系列 —（1）手势缩放图片功能</a>中，我们已经学会了如何用手势来对图片进行缩放。这次我们继续来看第二个操作，那就是如何用手势来旋转图片。</p><p>所以我们本文我们一共要实现二个功能：</p><ol><li>根据二个手指头的旋转来使图片跟着旋转</li><li>当二个手指头放开后，图片会自动回归到合适的位置。</li></ol><blockquote><p>我说明下第二个功能点的意思：什么叫回归到合适的位置，比如如图一，我们只转动了一点点，没有超过45度，然后放在手指，然后就会回到图二的样子。但是如果超过了45度，然后放开手指，就回变成图三的样子。</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/1529568-5deaaef977f86022.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图一"><br><img src="http://upload-images.jianshu.io/upload_images/1529568-ddc205e8375fc0ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图二"><br><img src="http://upload-images.jianshu.io/upload_images/1529568-ab82fe1fe938efc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="图三"></p><hr><p>前面基本的东西说明我都不说了。比如Matrix等知识。大家可以直接参考<a href="https://juejin.im/post/59fbdf5851882554bd5068ed" target="_blank" rel="noopener">图片操作系列 —（1）手势缩放图片功能</a>。</p><blockquote><p>ps:我这边可以再贴出相关基础的链接：<br><a href="http://blog.csdn.net/cquwentao/article/details/51445269" target="_blank" rel="noopener">android matrix 最全方法详解与进阶（完整篇）</a><br><a href="http://www.cnblogs.com/qiengo/archive/2012/06/30/2570874.html#code" target="_blank" rel="noopener">Android Matrix</a></p></blockquote><hr><h2 id="根据二个手指头的旋转来使图片跟着旋转："><a href="#根据二个手指头的旋转来使图片跟着旋转：" class="headerlink" title="根据二个手指头的旋转来使图片跟着旋转："></a>根据二个手指头的旋转来使图片跟着旋转：</h2><p>我们知道使图片进行旋转特定的角度很简单：</p><p>使用<code>Matrix.postRotate(float degrees, float px, float py)</code>方法即可。绕着<code>(px,py)</code>点进行旋转<code>degrees</code>角度。</p><p>所以我们的问题就变成了如果获取二个手指头在做旋转手势的时候，相应的角度的变化，从而通过Matrix.postRotate方法来让图片也跟着变化。</p><h4 id="1-获取二个手指头的手势监听"><a href="#1-获取二个手指头的手势监听" class="headerlink" title="1.获取二个手指头的手势监听"></a>1.获取二个手指头的手势监听</h4><p>在<a href="https://juejin.im/post/59fbdf5851882554bd5068ed" target="_blank" rel="noopener">图片操作系列 —（1）手势缩放图片功能</a>文中我们知道，控制图片的缩放是专门有个<code>ScaleGestureDetector</code>;在<code>OnTouch</code>事件中把相应的事件传递给<code>ScaleGestureDetector</code>。然后监听处理。我们也可以模仿着写一个<code>RotateGestureDetector</code>来进行图片旋转的监听和处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public interface IRotateDetector &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * handle rotation in onTouchEvent</span><br><span class="line">     *</span><br><span class="line">     * @param event The motion event.</span><br><span class="line">     * @return True if the event was handled, false otherwise.</span><br><span class="line">     */</span><br><span class="line">    boolean onTouchEvent(MotionEvent event);</span><br><span class="line"></span><br><span class="line">        /**</span><br><span class="line">     * is the Gesture Rotate</span><br><span class="line">     *</span><br><span class="line">     * @return true:rotating;false,otherwise</span><br><span class="line">     */</span><br><span class="line">    boolean isRotating();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">public class RotateGestureDetector implements IRotateDetector&#123;</span><br><span class="line"></span><br><span class="line">    private int mLastAngle = 0;//最后一次的角度值</span><br><span class="line">    private IRotateListener mListener;//用来旋转的回调Listener</span><br><span class="line">    private boolean mIsRotate;//是否处于旋转</span><br><span class="line"></span><br><span class="line">    //用来设置回调Listener的方法</span><br><span class="line">    public void setRotateListener(IRotateListener listener) &#123;</span><br><span class="line">        this.mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //用来接收触摸事件</span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        return doRotate(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //真正的计算手势操作所得到的角度值的方法，及回调调用。</span><br><span class="line">    private boolean doRotate(MotionEvent ev) &#123;</span><br><span class="line">        if (ev.getPointerCount() != 2) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        //Calculate the angle between the two fingers</span><br><span class="line">        int pivotX = (int) (ev.getX(0) + ev.getX(1)) / 2;</span><br><span class="line">        int pivotY = (int) (ev.getY(0) + ev.getY(1)) / 2;</span><br><span class="line">        float deltaX = ev.getX(0) - ev.getX(1);</span><br><span class="line">        float deltaY = ev.getY(0) - ev.getY(1);</span><br><span class="line"></span><br><span class="line">        double radians = Math.atan(deltaY / deltaX);</span><br><span class="line"></span><br><span class="line">        int degrees = (int) Math.round(Math.toDegrees(Math.atan2(deltaY,deltaX)));</span><br><span class="line"></span><br><span class="line">        switch (ev.getActionMasked()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                mLastAngle = degrees;</span><br><span class="line">                mIsRotate = false;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_UP:</span><br><span class="line">                mIsRotate = false;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_POINTER_DOWN:</span><br><span class="line">                mLastAngle = degrees;</span><br><span class="line">                mIsRotate = false;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_CANCEL:</span><br><span class="line">            case MotionEvent.ACTION_POINTER_UP:</span><br><span class="line">                mIsRotate = false;</span><br><span class="line">                upRotate(pivotX, pivotY);</span><br><span class="line">                mLastAngle = degrees;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                mIsRotate = true;</span><br><span class="line">                int degreesValue = degrees  - mLastAngle;</span><br><span class="line">                if (degreesValue &gt; 45) &#123;</span><br><span class="line">                    //Going CCW across the boundary</span><br><span class="line">                    rotate(-5, pivotX, pivotY);</span><br><span class="line">                &#125; else if (degreesValue &lt; -45) &#123;</span><br><span class="line">                    //Going CW across the boundary</span><br><span class="line">                    rotate(5, pivotX, pivotY);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    //Normal rotation, rotate the difference</span><br><span class="line">                    rotate(degreesValue, pivotX, pivotY);</span><br><span class="line">                &#125;</span><br><span class="line">                //Save the current angle</span><br><span class="line">                mLastAngle = degrees;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //回调的方法之一：控制图片根据手势的变化实时进行旋转</span><br><span class="line">    private void rotate(int degree, int pivotX, int pivotY) &#123;</span><br><span class="line">        if (mListener != null) &#123;</span><br><span class="line">            mListener.rotate(degree, pivotX, pivotY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //回调的方法之一：最后某个手指放开后，控制图片自动回归到合适的位置。</span><br><span class="line">    private void upRotate(int pivotX, int pivotY) &#123;</span><br><span class="line">        if (mListener != null) &#123;</span><br><span class="line">            mListener.upRotate(pivotX, pivotY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-获取二个手指头的角度变化"><a href="#2-获取二个手指头的角度变化" class="headerlink" title="2.获取二个手指头的角度变化"></a>2.获取二个手指头的角度变化</h4><p>所以我们只需要来分析一下具体<code>OnTouch</code>事件中的<code>doRotate</code>方法即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">//真正的计算手势操作所得到的角度值的方法，及回调调用。</span><br><span class="line">private boolean doRotate(MotionEvent ev) &#123;</span><br><span class="line">    //如果触摸的手指头不是2个，直接返回。</span><br><span class="line">    if (ev.getPointerCount() != 2) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //获取二个手指头的中心点的X与Y值，等会选择二个手指头的中心点作为旋转的中心</span><br><span class="line">    int pivotX = (int) (ev.getX(0) + ev.getX(1)) / 2;</span><br><span class="line">    int pivotY = (int) (ev.getY(0) + ev.getY(1)) / 2;</span><br><span class="line">    //获取二个手指头之间的X和Y的差值</span><br><span class="line">    float deltaX = ev.getX(0) - ev.getX(1);</span><br><span class="line">    float deltaY = ev.getY(0) - ev.getY(1);</span><br><span class="line">    //获取角度</span><br><span class="line">    int degrees = (int) Math.round(Math.toDegrees(Math.atan2(deltaY,deltaX)));</span><br><span class="line"></span><br><span class="line">    switch (ev.getActionMasked()) &#123;</span><br><span class="line">        case MotionEvent.ACTION_DOWN:</span><br><span class="line">            mLastAngle = degrees;</span><br><span class="line">            mIsRotate = false;</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_UP:</span><br><span class="line">            mIsRotate = false;</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_POINTER_DOWN:</span><br><span class="line">            mLastAngle = degrees;</span><br><span class="line">            mIsRotate = false;</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_CANCEL:</span><br><span class="line">        case MotionEvent.ACTION_POINTER_UP:</span><br><span class="line">            mIsRotate = false;</span><br><span class="line">            upRotate(pivotX, pivotY);</span><br><span class="line">            mLastAngle = degrees;</span><br><span class="line">            break;</span><br><span class="line">        case MotionEvent.ACTION_MOVE:</span><br><span class="line">            mIsRotate = true;</span><br><span class="line">            /*</span><br><span class="line">            每次把上一次的角度赋值给mLastAngle，然后获取当前新获取的角度degrees，</span><br><span class="line">            二者相减获取到二个手指头在移动的时候相应的角度变化。</span><br><span class="line">            */</span><br><span class="line">            int degreesValue = degrees  - mLastAngle;</span><br><span class="line"></span><br><span class="line">            /*</span><br><span class="line">            这里主要出现这么个情况，二个手指头如果相隔有一段距离，那么在移动的过程中，角度不会一下子变化很大.</span><br><span class="line">            但是比如我们这里故意二个手指头是碰在一起的,然后二个手指头稍微动一下，你就会发现角度变化会很大。</span><br><span class="line">            这样图片就会瞬间也旋转了很大的角度，让人体验感觉很怪，所以我们这里瞬间顺时针或者逆时针超过45度，都只移动5度值。</span><br><span class="line">            */</span><br><span class="line">            if (degreesValue &gt; 45) &#123;</span><br><span class="line">                rotate(-5, pivotX, pivotY);</span><br><span class="line">            &#125; else if (degreesValue &lt; -45) &#123;</span><br><span class="line">                rotate(5, pivotX, pivotY);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rotate(degreesValue, pivotX, pivotY);</span><br><span class="line">            &#125;</span><br><span class="line">            //Save the current angle</span><br><span class="line">            mLastAngle = degrees;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>doRotate方法</code>中最主要的就是根据二个手指头触摸获取到的X,Y的差值，根据Math.atan2来获取到角度。我们具体来看下为什么这样可以来获取角度：</p><p>先附上一个基础概念：<a href="http://bywyu.blog.163.com/blog/static/18999318620113159917830/" target="_blank" rel="noopener">Math.atan与Math.atan2</a></p><p><img src="http://upload-images.jianshu.io/upload_images/1529568-ca2e5fe870def4fe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>假设我们先点击了(50,50),再点击(10,10),这时候我们的deltaX = 40，deltaY = 40;也就是说<br>我们的弧度就是<code>Math.atan2(40,40)</code>，而角度就是再用<code>Math.toDegrees</code>对弧度进行转换即可。最终获得额角度是45度。</p><p>我们可以通过图形来查看为什么Math.atan2(40,40)对应的角度是45度。<br><img src="http://upload-images.jianshu.io/upload_images/1529568-06ec6cace3436238?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>如果我们的第二个手指头从(10,10)移动到了(50,10)，也就是说最后变成了<code>Math.atan2(40,0)</code>,根据图形来看我们就知道是：</p><p><img src="http://upload-images.jianshu.io/upload_images/1529568-e3313521952840e2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>所以一共旋转了45度，所以我们的图片也跟着顺时针旋转45度即可。</p><p>那假如我们的二个手指头的放入顺序反过来，变成：</p><p><img src="http://upload-images.jianshu.io/upload_images/1529568-124978c42827b327?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>那这时候就变成了<code>Math.atan2(-40,-40)</code>,我们根据图形就知道了角度：<br><img src="http://upload-images.jianshu.io/upload_images/1529568-0667d71c6dfc532c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>这时候还是跟刚才一样的操作，把（10,10）这个点移动到了（50,10），那这时候就是<code>Math.atan2(-40,0)</code>;</p><p><img src="http://upload-images.jianshu.io/upload_images/1529568-ad2e91fa6955e1fe?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>所以最终得到的旋转的角度是（-135）-（-90） = 45度，所以最终也是顺时针旋转45度。所以我们不管是哪个手指头先放下都不影响结果。</p><blockquote><p>也许有人就会问了,你这边按照二个手指的中点作为旋转中心去旋转，岂不是会旋转超出原来的图片的边界。如果你还记得我们上一篇文章：<a href="https://juejin.im/post/59fbdf5851882554bd5068ed" target="_blank" rel="noopener">图片操作系列 —（1）手势缩放图片功能</a>，这篇文章最后的内容讲的就是当图片超过边界，如果能随着手势慢慢回到边界里面：<code>checkMatrixBounds()</code>。</p></blockquote><h4 id="3-在Activity中设置Listener来进行图片的旋转"><a href="#3-在Activity中设置Listener来进行图片的旋转" class="headerlink" title="3.在Activity中设置Listener来进行图片的旋转"></a>3.在Activity中设置Listener来进行图片的旋转</h4><p>然后我们只需要在相应的Activity处对回调回来的<code>(degreesValue, pivotX, pivotY)</code>三个值做相应的旋转即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">rotateGestureDetector.setRotateListener(new IRotateListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void rotate(int degree, int pivotX, int pivotY) &#123;</span><br><span class="line">        //图片跟着手势进行旋转</span><br><span class="line">        mSuppMatrix.postRotate(degree, pivotX, pivotY);</span><br><span class="line">        //Post the rotation to the image</span><br><span class="line">        checkAndDisplayMatrix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void upRotate(int pivotX, int pivotY) &#123;</span><br><span class="line"></span><br><span class="line">        //当手指头松开的时候，让图片自动更新到合适的位置。</span><br><span class="line">        float[] v = new float[9];</span><br><span class="line">        mSuppMatrix.getValues(v);</span><br><span class="line">        // calculate the degree of rotation</span><br><span class="line">        int angle = (int) Math.round(Math.toDegrees(Math.atan2(v[Matrix.MSKEW_Y], v[Matrix.MSCALE_X])));</span><br><span class="line"></span><br><span class="line">        mRightAngleRunnable = new RightAngleRunnable(angle, pivotX, pivotY);</span><br><span class="line">        photoView.post(mRightAngleRunnable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><hr><h2 id="手指头松开手图片自动旋转到合适位置："><a href="#手指头松开手图片自动旋转到合适位置：" class="headerlink" title="手指头松开手图片自动旋转到合适位置："></a>手指头松开手图片自动旋转到合适位置：</h2><p>我们知道，前面图片跟着旋转，是获取到了<code>(int degree, int pivotX, int pivotY)</code>这三个值，然后让<code>mSuppMatrix.postRotate(degree, pivotX, pivotY)</code>;那我们就当手指头松开的时候，获取到最终这个图片比原来变化了多少角度即可。然后根据这个当前最终图片的变化角度来进行适当的旋转，让其旋转到合适位置。</p><p>我们来具体看怎么实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void upRotate(int pivotX, int pivotY) &#123;</span><br><span class="line"></span><br><span class="line">    //当手指头松开的时候，让图片自动更新到合适的位置。</span><br><span class="line">    float[] v = new float[9];</span><br><span class="line">    mSuppMatrix.getValues(v);</span><br><span class="line">    // calculate the degree of rotation</span><br><span class="line">    int angle = (int) Math.round(Math.toDegrees(Math.atan2(v[Matrix.MSKEW_Y], v[Matrix.MSCALE_X])));</span><br><span class="line"></span><br><span class="line">    mRightAngleRunnable = new RightAngleRunnable(angle, pivotX, pivotY);</span><br><span class="line">    photoView.post(mRightAngleRunnable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><a href="https://www.cnblogs.com/pen-ink/archive/2013/06/05/3118289.html" target="_blank" rel="noopener">Matrix</a>，中文里叫矩阵，高等数学里有介绍，在图像处理方面，主要是用于平面的缩放、平移、旋转等操作。在Android里面，Matrix由9个float值构成，是一个3*3的矩阵。最好记住。如下图：<br><img src="http://upload-images.jianshu.io/upload_images/1529568-192b52f47ccf3abc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="http://upload-images.jianshu.io/upload_images/1529568-f08d0e1105209588?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><img src="http://upload-images.jianshu.io/upload_images/1529568-c3824a6fa814d295?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p></blockquote><p>我们发现mSuppMatrix.getValues(v)方法返回的9个float值中，第一个为cosX,第四个为sinX，所以我们就取下标为0和3的值，也就是MSCALE_X和MSKEW_Y。我们用<code>Math.atan2(v[Matrix.MSKEW_Y], v[Matrix.MSCALE_X])来获取弧度。再用Math.toDegrees来获取相应的最终图片的旋转的度数。</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class Matrix &#123;</span><br><span class="line"></span><br><span class="line">    public static final int MSCALE_X = 0;   //!&lt; use with getValues/setValues</span><br><span class="line">    public static final int MSKEW_X  = 1;   //!&lt; use with getValues/setValues</span><br><span class="line">    public static final int MTRANS_X = 2;   //!&lt; use with getValues/setValues</span><br><span class="line">    public static final int MSKEW_Y  = 3;   //!&lt; use with getValues/setValues</span><br><span class="line">    public static final int MSCALE_Y = 4;   //!&lt; use with getValues/setValues</span><br><span class="line">    public static final int MTRANS_Y = 5;   //!&lt; use with getValues/setValues</span><br><span class="line">    public static final int MPERSP_0 = 6;   //!&lt; use with getValues/setValues</span><br><span class="line">    public static final int MPERSP_1 = 7;   //!&lt; use with getValues/setValues</span><br><span class="line">    public static final int MPERSP_2 = 8;   //!&lt; use with getValues/setValues</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们再把获取到的角度和中心点，通过一个Runnable来进行图片最后的矫正：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mRightAngleRunnable = new RightAngleRunnable(angle, pivotX, pivotY);</span><br><span class="line">photoView.post(mRightAngleRunnable);</span><br></pre></td></tr></table></figure></p><p>我们知道最后是RightAngleRunnable来进行图片的矫正，所以我们具体来分析下这个Runnable:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">class RightAngleRunnable implements Runnable &#123;</span><br><span class="line">        private static final int RECOVER_SPEED = 4;</span><br><span class="line">        private int mOldDegree;</span><br><span class="line">        private int mNeedToRotate;</span><br><span class="line">        private int mRoPivotX;</span><br><span class="line">        private int mRoPivotY;</span><br><span class="line"></span><br><span class="line">        RightAngleRunnable(int degree, int pivotX, int pivotY) &#123;</span><br><span class="line">            Log.v(&quot;dyp4&quot;, &quot;oldDegree:&quot; + degree + &quot;,&quot; + &quot;calDegree:&quot; + calDegree(degree));</span><br><span class="line">            this.mOldDegree = degree;</span><br><span class="line">            this.mNeedToRotate = calDegree(degree);</span><br><span class="line">            this.mRoPivotX = pivotX;</span><br><span class="line">            this.mRoPivotY = pivotY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //最终计算需要矫正的角度值</span><br><span class="line">        /*</span><br><span class="line">            例如：</span><br><span class="line"></span><br><span class="line">            比如最终是60度，这时候其实是超过了45度，应该矫正成90度，</span><br><span class="line">            所以最终要多给它30度。顺时针多选择30度。这里计算会得到30。</span><br><span class="line"></span><br><span class="line">            比如如果是-60度，这时候应该是变成-90读，所以我们逆时针多旋转30度。</span><br><span class="line">            这时候计算会得到-30。</span><br><span class="line"></span><br><span class="line">            如果是20度，这时候没有超过45度，所以应该矫正成0度，</span><br><span class="line">            所以最终要逆时针转回20度，所以这里计算会得到-20。</span><br><span class="line"></span><br><span class="line">            如果是-120度，这时候要变成-90度，所以要顺时针转回30度，</span><br><span class="line">            所以计算会得到30。</span><br><span class="line">        */</span><br><span class="line">        private int calDegree(int oldDegree) &#123;</span><br><span class="line">            int N = Math.abs(oldDegree) / 45;</span><br><span class="line">            if ((0 &lt;= N &amp;&amp; N &lt; 1) || 2 &lt;= N &amp;&amp; N &lt; 3) &#123;</span><br><span class="line">                return -oldDegree % 45;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (oldDegree &lt; 0) &#123;</span><br><span class="line">                    return -(45 + oldDegree % 45);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return (45 - oldDegree % 45);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        /*</span><br><span class="line">        我们上面的calDegree方法可以获得我们需要矫正的角度，但是我们不是一下子就让图片选择N度，而是慢慢的转过来。</span><br><span class="line">        比如我们用RECOVER_SPEED = 4，4度的慢慢来旋转过来，不会给用户很突兀的感觉。</span><br><span class="line">        */</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            if (mNeedToRotate == 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (photoView == null) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mNeedToRotate &gt; 0) &#123;</span><br><span class="line">                //Clockwise rotation</span><br><span class="line">                if (mNeedToRotate &gt;= RECOVER_SPEED) &#123;</span><br><span class="line">                    mSuppMatrix.postRotate(RECOVER_SPEED, mRoPivotX, mRoPivotY);</span><br><span class="line">                    mNeedToRotate -= RECOVER_SPEED;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mSuppMatrix.postRotate(mNeedToRotate, mRoPivotX, mRoPivotY);</span><br><span class="line">                    mNeedToRotate = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else if (mNeedToRotate &lt; 0) &#123;</span><br><span class="line">                //Counterclockwise rotation</span><br><span class="line">                if (mNeedToRotate &lt;= -RECOVER_SPEED) &#123;</span><br><span class="line">                    mSuppMatrix.postRotate(-RECOVER_SPEED, mRoPivotX, mRoPivotY);</span><br><span class="line">                    mNeedToRotate += RECOVER_SPEED;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    mSuppMatrix.postRotate(mNeedToRotate, mRoPivotX, mRoPivotY);</span><br><span class="line">                    mNeedToRotate = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            checkAndDisplayMatrix();</span><br><span class="line">            Compat.postOnAnimation(photoView, this);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>还是老样子，希望大家不要吐槽。有问题留言哈哈。。O(∩_∩)O哈哈~<br>PS：有好的画图软件介绍吗。。求介绍o(╥﹏╥)o</p><p>附上Demo地址：<a href="https://github.com/qaz349293703/ScaleImageVewDemo" target="_blank" rel="noopener">ScaleImageVewDemo</a>（已经把图片旋转的Activity demo 加入里面）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1529568-f083a0346aa3af63.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;文章摘要：根据手势操作图片旋转&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="PhotoView" scheme="http://yoursite.com/tags/PhotoView/"/>
    
  </entry>
  
  <entry>
    <title>图片操作系列 —（1）手势缩放图片功能</title>
    <link href="http://yoursite.com/2017/11/07/%E5%9B%BE%E7%89%87%E6%93%8D%E4%BD%9C%E7%B3%BB%E5%88%97%E2%80%94%EF%BC%881%EF%BC%89%E6%89%8B%E5%8A%BF%E7%BC%A9%E6%94%BE%E5%9B%BE%E7%89%87%E5%8A%9F%E8%83%BD/"/>
    <id>http://yoursite.com/2017/11/07/图片操作系列—（1）手势缩放图片功能/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2017-12-19T07:02:50.159Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1529568-b9fda7a0f041e6ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>文章摘要：根据手势缩放图片<br><a id="more"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>项目开发中，大家APP开发一般都会用到上传图片，比如是上传了自己的生活照，然后在某个界面处查看上传的图片，这时候一般在这个查看详情的界面，会有手势放大缩小功能，手势进行旋转功能，双击放大图片等等。</p><p>不巧，我以前也有需要这个需求的时候，而且特别指出了要用手势进行图片的选择功能。</p><p>于是我查看了BiliBili的开源库：</p><h3 id="Boxing"><a href="#Boxing" class="headerlink" title="Boxing"></a><a href="https://github.com/Bilibili/boxing" target="_blank" rel="noopener">Boxing</a></h3><p><img src="http://upload-images.jianshu.io/upload_images/1529568-e55ef7f86878961c?imageMogr2/auto-orient/strip" alt="image"></p><p>使用了这个Demo后发现里面有手势控制图片大小，手势控制图片旋转等功能，看了代码后我发现BiliBili这个demo中也是用了第三方的库：</p><h3 id="RotatePhotoView"><a href="#RotatePhotoView" class="headerlink" title="RotatePhotoView"></a><a href="https://github.com/ChenSiLiang/RotatePhotoView" target="_blank" rel="noopener">RotatePhotoView</a></h3><p><img src="http://upload-images.jianshu.io/upload_images/1529568-bceb55c131366d0e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="http://upload-images.jianshu.io/upload_images/1529568-cdf4916a57ece3b4?imageMogr2/auto-orient/strip" alt="image"></p><p>我们可以看到介绍：在PhotoView的基础上添加了通过二个手指来旋转图片的功能，所以这个库又是用了其他的第三方库：</p><h3 id="PhotoView"><a href="#PhotoView" class="headerlink" title="PhotoView"></a><a href="https://github.com/chrisbanes/PhotoView" target="_blank" rel="noopener">PhotoView</a></h3><p>我们可以看到这个PhotoView的库有一万多个star了。说明还是很不错的。</p><p>所以通过这次。我就来看PhotoView如何进行实现那么多功能。</p><hr><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><blockquote><p>大家在看正文之前如果对于Matrix不是很了解的，可以先看看:<br><a href="http://blog.csdn.net/cquwentao/article/details/51445269" target="_blank" rel="noopener">android matrix 最全方法详解与进阶（完整篇）</a><br><a href="http://www.cnblogs.com/qiengo/archive/2012/06/30/2570874.html#code" target="_blank" rel="noopener">Android Matrix</a><br><a href="http://www.jianshu.com/p/ca4dbe764451" target="_blank" rel="noopener">Float中的那些常量 Infinity、NaN</a></p></blockquote><p>本来是想直接拿着PhotoView 的源码，贴上源码分析一个个具体的功能，但是因为源码是考虑到很多功能，所以有很多代码量，而且太多看着很乱，所以我的方案是直接自己写个demo，然后根据我们要讲解的功能，仿照PhotoView的源码，在自己一个个具体的功能demo分别实现。所以本文我先来实现实现根据手势来实现图片的缩放功能：</p><h3 id="1-添加图片布局"><a href="#1-添加图片布局" class="headerlink" title="1.添加图片布局"></a>1.添加图片布局</h3><p>PhotoView是继承了ImageView，然后直接在layout中使用<photoview>，为了更方便的讲解，我就直接还是使用<imageview>，然后让大家看到是如何对ImageView做处理实现相应的功能。</imageview></photoview></p><p>先添加我们要的demo布局：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    tools:context=&quot;com.example.dialog.photoviewdemo.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id=&quot;@+id/photo_view&quot;</span><br><span class="line">        android:layout_width=&quot;match_parent&quot;</span><br><span class="line">        android:layout_height=&quot;match_parent&quot;</span><br><span class="line">        android:background=&quot;@android:color/black&quot;</span><br><span class="line">        /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br></pre></td></tr></table></figure></p><h3 id="2-对图片设置手势监听"><a href="#2-对图片设置手势监听" class="headerlink" title="2. 对图片设置手势监听"></a>2. 对图片设置手势监听</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">    //对我们的ImageView设置相应的一张图片</span><br><span class="line">    ivPhoto = (ImageView) findViewById(R.id.photo_view);</span><br><span class="line">    drawable = ContextCompat.getDrawable(this, R.mipmap.ic_launcher);</span><br><span class="line">    ivPhoto.setImageDrawable(drawable);</span><br><span class="line"></span><br><span class="line">    //对我们的ImageView设置触摸事件监听，并且把监听交给了GestureDetector.</span><br><span class="line">    ivPhoto.setOnTouchListener(new View.OnTouchListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onTouch(View v, MotionEvent event) &#123;</span><br><span class="line">           return scaleGestureDetector.onTouchEvent(event);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    //GestureDetector的实例生成</span><br><span class="line">    scaleGestureDetector = new ScaleGestureDetector(this, new ScaleGestureDetector.OnScaleGestureListener() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public boolean onScale(ScaleGestureDetector detector) &#123;</span><br><span class="line">            float scaleFactor = detector.getScaleFactor();</span><br><span class="line">            float focusX = detector.getFocusX();</span><br><span class="line">            float focusY = detector.getFocusY();</span><br><span class="line">            if (Float.isNaN(scaleFactor) || Float.isInfinite(scaleFactor)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mSuppMatrix.postScale(scaleFactor, scaleFactor, focusX, focusY);</span><br><span class="line">            if(checkMatrixBounds()) &#123;</span><br><span class="line">                ivPhoto.setImageMatrix(getDrawMatrix());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public boolean onScaleBegin(ScaleGestureDetector detector) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onScaleEnd(ScaleGestureDetector detector) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的代码我们一样样来分析：</p><h4 id="1-GestureDetector和ScaleGestureDetector"><a href="#1-GestureDetector和ScaleGestureDetector" class="headerlink" title="1.GestureDetector和ScaleGestureDetector"></a>1.GestureDetector和ScaleGestureDetector</h4><p>当用户触摸屏幕的时候，会产生许多手势，例如down，up，scroll，filing等等。<br>一般情况下，我们知道View类有个View.OnTouchListener内部接口，通过重写他的onTouch(View v, MotionEvent event)方法，我们可以处理一些touch事件，但是这个方法太过简单，如果需要处理一些复杂的手势，用这个接口就会很麻烦（因为我们要自己根据用户触摸的轨迹去判断是什么手势）。<br>Android sdk给我们提供了GestureDetector（Gesture：手势Detector：识别）类，通过这个类我们可以识别很多的手势，主要是通过他的onTouchEvent(event)方法完成了不同手势的识别。虽然他能识别手势，但是不同的手势要怎么处理，应该是提供给程序员实现的。<br>具体具体可以看这篇文章，写的很详细：<a href="http://blog.csdn.net/harvic880925/article/details/39520901" target="_blank" rel="noopener">用户手势检测-GestureDetector使用详解</a></p><p>而此处我们因为做的功能是通过手势来<strong>缩放图片</strong>，所以我们就要监听二个手指头<strong>缩放动作</strong>,所以我们使用的是<strong>ScaleGestureDetector</strong>。</p><blockquote><p>ScaleGestureDetector介绍:<br>用于处理缩放的工具类，用法与GestureDetector类似，都是通过onTouchEvent()关联相应的MotionEvent的。使用该类时，用户需要传入一个完整的连续不断地motion事件（包含ACTION_DOWN,ACTION_MOVE和ACTION_UP事件）。</p></blockquote><p>我们看上面的代码就会发现ScaleGestureDetector有三个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onScale(ScaleGestureDetector detector) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public boolean onScaleBegin(ScaleGestureDetector detector) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onScaleEnd(ScaleGestureDetector detector) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p><code>onScaleBegin</code>:缩放开始会执行的方法，但是我们发现这个方法需要返回一个<code>Boolean</code>值，这个值决定是否处理后继的缩放事件,返回<code>false</code>时，不会执行<code>onScale()</code>。</p><p><code>onScaleEnd</code>:缩放结束执行</p><p><code>onScale</code>:缩放时候执行的方法，用来做具体的逻辑处理。</p><p>我们具体来看看<code>onScale</code>方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onScale(ScaleGestureDetector detector) &#123;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到这里是返回Boolean值，那这里返回true和false有什么区别呢。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float scaleFactor = detector.getScaleFactor();</span><br></pre></td></tr></table></figure></p><p>我们可以通过这个方法获取到缩放因子，缩放因子会根据你的手势的变大会越来越大，如果你返回了true，那就说明这次的缩放行为就已经结束了，如果你返回了false，那就说明没有结束，然后缩放因子越来越大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public boolean onScale(ScaleGestureDetector detector) &#123;</span><br><span class="line">    if(detector.getScaleFactor()&lt; 2)&#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://upload-images.jianshu.io/upload_images/1529568-74a87c0ad76212ae?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>我们可以看到，我们设置了大于2才返回true，（前提二个手指是做放大手势）那么缩放因子就会一直变大到2，才会认为这次缩放行为结束了，就再次从1开始了。</p><blockquote><p>（PS:如果二个手指做缩小的手势，那么这个缩放因子就会小于1，如果返回false，那么就会从1开始越来越小。）</p></blockquote><h4 id="2-图片初始化呈现状态"><a href="#2-图片初始化呈现状态" class="headerlink" title="2.图片初始化呈现状态"></a>2.图片初始化呈现状态</h4><p>假设我们现在的ImageView设置的是全屏，我们有个小图片，ImageView设置了图片后是这样的：</p><p><img src="http://upload-images.jianshu.io/upload_images/1529568-26db8cc8d9562255?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>我们发现默认是在左上角，而且因为我们的ImageView设置的是全屏，而图片又特别小，这样的初步呈现方式很不友好。<br>所以我们要做如下操作：<br><strong><1>把图片居中显示。</1></strong><br><strong><2>图片和ImageView相适应(我们这里是把图片适当的放大，来适应这么大的ImageView.)</2></strong></p><p>所以也就是我们上面提到过的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">drawableWidth = drawable.getIntrinsicWidth();</span><br><span class="line">drawableHeight = drawable.getIntrinsicHeight();</span><br><span class="line"></span><br><span class="line">viewWidth = ivPhoto.getWidth() - ivPhoto.getPaddingLeft() - ivPhoto.getPaddingRight();</span><br><span class="line">viewHeight = ivPhoto.getHeight() - ivPhoto.getPaddingLeft() - ivPhoto.getPaddingRight();</span><br><span class="line">RectF mTempScr = new RectF(0, 0, drawableWidth, drawableHeight);</span><br><span class="line">RectF mTempDst = new RectF(0, 0, viewWidth, viewHeight);</span><br><span class="line">mBaseMatrix.setRectToRect(mTempScr, mTempDst, Matrix.ScaleToFit.CENTER);</span><br><span class="line">mDrawableMatrix.set(mBaseMatrix);</span><br><span class="line">ivPhoto.setImageMatrix(mDrawableMatrix);</span><br></pre></td></tr></table></figure></p><p>获取图片的真实宽高和ImageView用来显示图片的宽高我就不多说了。重点是<code>setRectToRect</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public boolean setRectToRect(RectF src, RectF dst, ScaleToFit stf)</span><br></pre></td></tr></table></figure><p>将rect变换成rect，通过stf参数来控制。</p><blockquote><p>ScaleToFit 有如下四个值：<br>FILL: 可能会变换矩形的长宽比，保证变换和目标矩阵长宽一致。<br>START:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。左上对齐。<br>CENTER: 保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。<br>END:保持坐标变换前矩形的长宽比，并最大限度的填充变换后的矩形。至少有一边和目标矩形重叠。右下对齐。</p></blockquote><p>这里使用谷歌的api demo的图片作为例子：</p><p><img src="http://upload-images.jianshu.io/upload_images/1529568-2fedfc4125127377?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><p>我们很明显发现，那个蓝色的小球的变化不就是我们想要的变化么，并且我们是要居中，所以用的是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们看下我们最终的效果：</span><br><span class="line"></span><br><span class="line">![image](http://upload-images.jianshu.io/upload_images/1529568-4f62cddad80877a5?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">#### 3.图片实时手势缩放</span><br><span class="line"></span><br><span class="line">我们前面已经知道了。手势变化的时候会触发``onScale``方法,所以我们只要把图片的具体的放大缩小的逻辑放在``onScale``里面即可。</span><br></pre></td></tr></table></figure></p><p>@Override<br>public boolean onScale(ScaleGestureDetector detector) {<br>    //缩放因子<br>    float scaleFactor = detector.getScaleFactor();<br>    //返回组成该手势的两个触点的中点在组件上的x和y轴坐标，单位为像素。<br>    float focusX = detector.getFocusX();<br>    float focusY = detector.getFocusY();<br>    //如果为nan或者无强大，则无效<br>    if (Float.isNaN(scaleFactor) || Float.isInfinite(scaleFactor)) {<br>        return false;<br>    }<br>    //进行缩放，传入x轴缩放比例，y轴缩放比例，缩放中心点的x和y值<br>    mSuppMatrix.postScale(scaleFactor, scaleFactor, focusX, focusY);<br>    if(checkMatrixBounds()) {<br>        ivPhoto.setImageMatrix(getDrawMatrix());<br>    }</p><pre><code>return true;</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大家应该看到了我这边有个``checkMatrixBounds``方法，本来其实单纯的缩放就是先``postScale``然后在直接``setImageMatrix``就可以了。</span><br></pre></td></tr></table></figure></p><p>mSuppMatrix.postScale(scaleFactor, scaleFactor, focusX, focusY);<br>ivPhoto.setImageMatrix(getDrawMatrix());<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">但是这样有什么不好的地方呢。我来具体跟大家说下：</span><br><span class="line">- 缩放跟手势的二个触点的中心有关，而且图片会随着那个方向移动</span><br><span class="line"></span><br><span class="line">![image](http://upload-images.jianshu.io/upload_images/1529568-4ff42972b840cdc4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">比如我是二个红点分别是我的手指，然后不停的缩小图片动作，图片不仅变小，而且会随着那个方向做平移。放大则相反。这不是我们想要的，我们想要的是同样是做缩放，同时，图片还在中间。</span><br><span class="line"></span><br><span class="line">**既然我们知道了图片在做缩小放大的同时还在平移，那我们就做相应的反方向的平移处理不就好了**</span><br><span class="line"></span><br><span class="line">我们分为二种情况：</span><br><span class="line">#### 1— 图片在缩放过程中，宽或者高没有超过ImageView的宽或者高：</span><br><span class="line">如果图片再缩放过程中没超过ImageView的大小。我们只需要让图片一直居中现实即可。所以比较简单：</span><br><span class="line"></span><br><span class="line">![image](http://upload-images.jianshu.io/upload_images/1529568-6324bacbbee4cbf0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line">只要算出我们在前面第二个大步里面的初始化后的图片的初始状态后（即和ImageView相适应并且居中），相应的图片的矩阵的宽和高是不是超过ImageView。如果没有超过，我们可以看到我们希望的图片放大和缩小都是希望在正中间的位置，但是现在变成了绿色的地方，我们只需要把绿色的地方移动到咖啡色的地方就行。</span><br><span class="line"></span><br><span class="line">以Y轴为例（X轴同样处理）：</span><br><span class="line"></span><br><span class="line">![image](http://upload-images.jianshu.io/upload_images/1529568-b1266889a852a0d1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line">看到距离是(实际图片的Top值) - (2分之一的ImageView的高度) + (2分之一的实际图片高度)，因为是往上移动，所以Y轴实际上是要减少值的，所以最终我们只要让实际的图片减去相应的距离值即可。</span><br><span class="line"></span><br><span class="line">- 实际图片的TOP值（先获取相应的实际图片的矩阵Rect，在获取top属性）：</span><br></pre></td></tr></table></figure></p><p>  private RectF getDisplayRect(Matrix matrix) {<br>    Drawable d = drawable;<br>    if (d != null) {<br>        mDisplayRect.set(0, 0, d.getIntrinsicWidth(), d.getIntrinsicHeight());<br>        matrix.mapRect(mDisplayRect);<br>        return mDisplayRect;<br>    }<br>    return null;<br>  }<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ImageView的高度：</span><br></pre></td></tr></table></figure></p><p>viewHeight = ivPhoto.getHeight() - ivPhoto.getPaddingLeft() - ivPhoto.getPaddingRight();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 实际变化后的图片的高度(rect为上面获取的实际图片的Rect)：</span><br><span class="line"> ``final float height = rect.height(), width = rect.width();``</span><br><span class="line"></span><br><span class="line">所以我们这里只需要：</span><br></pre></td></tr></table></figure></p><p>private boolean checkMatrixBounds() {<br>    RectF rect = getDisplayRect(getDrawMatrix());<br>    if (rect == null) {<br>        return false;<br>    }</p><pre><code>final float height = rect.height(), width = rect.width();float deltaX = 0, deltaY = 0;if (height &lt;= viewHeight) {    deltaY = (viewHeight - height) / 2 - rect.top;}if (width &lt;= viewWidth) {    deltaX = (viewWidth - width) / 2 - rect.left;} mSuppMatrix.postTranslate(deltaX, deltaY);return true;</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 2— 图片在缩放过程中，宽或者高超过ImageView的宽或者高：</span><br><span class="line">这个时候我们就不行简单的在中心位置就可以了。因为这时候不能反而不让他在中心位置，为什么？？？？我们现在的图片是一个安卓机器人，比如我现在要放大它的图片查看它的右眼，我们在右上角用手机不挺放大。变成这样：</span><br><span class="line"></span><br><span class="line">![&#125;)ZABEPQ(1V_&#125;6461ME&#123;O&#123;N.png](http://upload-images.jianshu.io/upload_images/1529568-f155aae6ea39a581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这时候就说了。那我什么都不处理，放大这边就是这个效果啊。说的没错的确这样，但是比如现在已经放大成这个样子了。我缩小它，但是我不是从右上角来进行缩小，而是在左边进行缩小，大家知道我们不做处理，这时候缩小的时候是按我们手势的位置进行，所以头像在缩小时候先是往左边方向，然后当小于ImageView的高度时候，又突然居中，效果很不好。</span><br><span class="line"></span><br><span class="line">所以我们这个例子里面处理方式是：如果宽度都大于ImageView并且图片的右边界还没出现在ImageView中的时候，先按照自己原来的方式缩小，当图片的右边界出现在了ImageView的范围内了，让它慢慢往右边移动（也就是ImageView的宽度 - Rect.right的距离），这时候就会很和谐。最后宽度小于ImageView的时候居于中间。</span><br><span class="line"></span><br><span class="line">&gt;PS:还有一种正好反过来。我们放大的图片是左眼！！（这时候移动的距离是 -rect.left）</span><br><span class="line"></span><br><span class="line">所以最终变成这样：</span><br></pre></td></tr></table></figure><p>private boolean checkMatrixBounds() {<br>    RectF rect = getDisplayRect(getDrawMatrix());<br>    if (rect == null) {<br>        return false;<br>    }</p><pre><code>final float height = rect.height(), width = rect.width();float deltaX = 0, deltaY = 0;if (height &lt;= viewHeight) {    deltaY = (viewHeight - height) / 2 - rect.top;} else if (rect.top &gt; 0) {    deltaY = -rect.top;} else if (rect.bottom &lt; viewHeight) {    deltaY = viewHeight - rect.bottom;}if (width &lt;= viewWidth) {    deltaX = (viewWidth - width) / 2 - rect.left;} else if (rect.left &gt; 0) {    deltaX = -rect.left;} else if (rect.right &lt; viewWidth) {    deltaX = viewWidth - rect.right;}mSuppMatrix.postTranslate(deltaX, deltaY);return true;</code></pre><p>}<br>```</p><hr><h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>还是老样子，希望大家不要吐槽。有问题留言哈哈。。O(∩_∩)O哈哈~</p><p>附上Demo地址：<a href="https://github.com/qaz349293703/ScaleImageVewDemo" target="_blank" rel="noopener">ScaleImageVewDemo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1529568-b9fda7a0f041e6ba.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;文章摘要：根据手势缩放图片&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://yoursite.com/categories/Android/"/>
    
    
      <category term="Matrix" scheme="http://yoursite.com/tags/Matrix/"/>
    
      <category term="PhotoView" scheme="http://yoursite.com/tags/PhotoView/"/>
    
  </entry>
  
</feed>
